# This file contains classes related to actions the user can perform

# A sub action can be a command or python function
import hashlib
import json

class Item:
    def __init__(self,label, html_label, html_id = None) -> None:
        self.type = "data"
        self.parent:Item_Holder # not set by item
        
        self.label = label
        self.html_label = label
        self.html_id = html_id # makes changing data easier. Only render if not null
        if html_label != None:
            self.html_label = html_label
        self.hash = None # not generated by Item

    def id_render(self):
        if self.html_id == None:
            return ""
        return f"id=\"{self.html_id}\""

    def r_c(self): # render constants
        return f"{self.id_render()} api-hash=\"{self.hash}\""

    def render_html(self):
        return f"<span {self.r_c()}>{self.html_label}</span>"

        

class Btn_Item(Item):
    def __init__(self, action_f, label:str, html_label:str, html_id = None,html_colour = "white") -> None:
        super().__init__(label, html_label, html_id=html_id)
        self.type = "btn"
        self.action_f = action_f
        self.html_colour = html_colour
        
        #self.info
        #self.perm_level

    def render_html(self):
        return f"<button class=\"ctlbtn\" {self.r_c()}>{self.html_label}</button>"

    def do_f(self):
        return self.action_f()


class Item_Holder:
    def __init__(self, label:str, html_label:str = None, catagory:str = None, items:list[Item] = None) -> None:
        self.label = label
        self.html_label = label
        if html_label != None:
            self.html_label = html_label

        self.catagory = catagory
        self.registerd_items:list[Item] = []
        
        for ac in items:
            self.register_item(ac)
        
    def register_item(self, item:Item) -> None:
        print(f"Registerd {item.label} to {self.label}")
        self.registerd_items.append(item)
        self.gen_hash(item)
        item.parent = self

    def gen_hash(self,item:Item):
        hash = hashlib.md5(f"{self.label}{item.label}".encode()).hexdigest()
        item.hash = hash
        return hash

    def reset_all_hashes(self):
        for item in self.registerd_items:
            self.gen_hash(item)

    def render_html(self):
        ohtml = ["<div class=\"cont\">", "<div class=\"flexcont\">",f"<div>{self.html_label}</div>"]
        ohtml.append("<div class=\"btncontainer\">")
        for item in self.registerd_items:
            ohtml.append(item.render_html())
        ohtml.append("</div>")
        ohtml.append("</div>")
        ohtml.append("</div>")
        return "\n".join(ohtml)

    def find_item_by_label(self, sLabel:str):
        for item in self.registerd_items:
            if item.label == sLabel:
                return item
        return None


class Holder:
    def __init__(self, item_holders:list[Item_Holder] = None) -> None:
        self.item_tree_dict = {}
        self.item_hash_dict = {} # easier for api query

        for itemH in item_holders:
            self.reg_item_holder(itemH)

    def reg_item_holder(self, item_holder:Item_Holder):
        if item_holder.catagory in self.item_tree_dict.keys():
            self.item_tree_dict[item_holder.catagory].append(item_holder)
        else:
            self.item_tree_dict[item_holder.catagory] = [item_holder]

        for item in item_holder.registerd_items:
            self.item_hash_dict[item.hash] = item

    def remove_item_holder(item_holder):
        pass


    def render_html(self):
        ohtml = []
        for cat, iHoldL in self.item_tree_dict.items():
            ohtml.append(f"<h2>{cat}</h2>")
            for iHold in iHoldL:
                ohtml.append(iHold.render_html())
        return "\n".join(ohtml)
            

    def __str__(self) -> str:
        return self.__repr__()

    def __repr__(self) -> str:
        return f"<{self.item_tree_dict}, {self.item_hash_dict}>"

        
class HTML_Change_Item:
    def __init__(self, content:str, html_id = None, api_hash = None) -> None:
        self.html_id = html_id
        self.api_hash = api_hash
        self.content = content
    
    def to_json(self):
        out_dict = {"content": self.content}
        if self.html_id != None:
            id_dict = {"id": self.html_id}
            out_dict = id_dict | out_dict
        if self.api_hash != None:
            api_dict = {"hash": self.api_hash}
            out_dict = api_dict | out_dict
        return json.dumps(out_dict)


class Data_Joiner:
    def __init__(self, item_holder:Item_Holder) -> None:
        self.item_holder = item_holder

class Power_State(Data_Joiner):
    def __init__(self) -> None:
        super().__init__(Item_Holder("power state", "Power State"))
        
    def get_power_state():
        pass